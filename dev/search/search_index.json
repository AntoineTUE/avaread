{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"AvaRead","text":"<p>A project for reading spectra from Avantes AvaSoft 8 files in Python.</p> <p>It supports all Avantes multichannel files (e.g. <code>.raw8</code>, <code>.rir8</code>, etc.), reading all avaible channels, as well as store-to-RAM/multiframe files (<code>.str8</code>).</p> <p>Importantly, this means you can work with these files directly in your analysis!</p> <ul> <li> <p>No need to convert your <code>.raw8</code> (or equivalent files) to work with them</p> </li> <li> <p>No need to convert your <code>.str8</code> into large sets of files with very similar names!</p> </li> </ul>"},{"location":"#installing","title":"Installing","text":"<p><code>AvaRead</code> can be easily installed with <code>pip</code> and only has <code>numpy</code> as a dependency, which will be installed if missing.</p> <p>You can install the latest release from PyPI:</p> <pre><code>pip install avaread\n</code></pre> <p>To install the latest development version from GitHub, you can use:</p> <pre><code>pip install git+https://github.com/AntoineTUE/avaread.git\n</code></pre>"},{"location":"#how-to-use","title":"How to use","text":"<p>Using <code>avaread</code> is fairly straightforward, you should be fine with using the <code>read_file</code> function to open any Avantes AvaSoft 8 file.</p> <p>Depending on the detected file type, you will either receive an instance of <code>AVSFile</code> or <code>STRFile</code>, which are iterable, container-like objects that give you access to the data and metadata read from the file.</p> <p>Most of the data is stored as <code>numpy.ndarray</code>s under the hood.</p> <p>Note that these files store data differently:</p> <ul> <li><code>AVSFile</code> stores data from multiple devices (or channels), one spectrum per device, which can be of different shape.</li> <li><code>STRFile</code> stores multiple spectra recorded in sequence by a single device (or channel).</li> </ul> <p>See also the documentation for more details and examples.</p> <pre><code>import avaread\nfrom avaread.reader import AVSFile, STRFile\nfrom pathlib import Path\nimport matplotlib.pyplot as plt\n\nfile1 = Path(\"path/to/file1.raw8\")\nfile2 = Path(\"path/to/file2.str8\")\n\ndata1 = avaread.read_file(file1)\ndata2 = avaread.read_file(file2)\n\nassert isinstance(data1, AVSFile)\nassert isinstance(data2, STRFile)\n\nplt.figure()\n# Plot the different channels stored in the `AVSFile`\nfor channel in data1:\n    plt.plot(channel.wavelength, channel.signal, label=f\"{channel.ID.SerialNumber}\")\n\nplt.figure()\n# Plot the different frames stored in the `STRFile`\nfor i, frame in enumerate(data2):\n    plt.plot(data2.wavelength, frame, label=f\"Delay: {data2.delay[i]} ms\")\n</code></pre>"},{"location":"#license","title":"License","text":"<p>AvaRead is licensed under the MIT license.</p> <p>See LICENSE.</p>"},{"location":"examples/","title":"Examples for using","text":"In\u00a0[1]: Copied! <pre>from pathlib import Path\nimport matplotlib.pyplot as plt\n\nimport avaread\n\nnormal_files = list(Path(\"../tests/test_files/\").glob(\"*.raw8\"))\nsequence_files = list(Path(\"../tests/test_files/\").glob(\"*.str8\"))\n</pre> from pathlib import Path import matplotlib.pyplot as plt  import avaread  normal_files = list(Path(\"../tests/test_files/\").glob(\"*.raw8\")) sequence_files = list(Path(\"../tests/test_files/\").glob(\"*.str8\")) In\u00a0[2]: Copied! <pre>for f in normal_files:\n    file = avaread.read_file(f)\n    plt.figure()\n    plt.title(file.name)\n    for channel in file:\n        plt.plot(channel.wavelength, channel.signal, label=f\"{channel.ID.SerialNumber}: {channel.exposure:.1f} ms\")\n    plt.legend()\n    plt.xlabel(\"wavelength (nm)\")\n    plt.ylabel(\"Counts (-)\")\n</pre> for f in normal_files:     file = avaread.read_file(f)     plt.figure()     plt.title(file.name)     for channel in file:         plt.plot(channel.wavelength, channel.signal, label=f\"{channel.ID.SerialNumber}: {channel.exposure:.1f} ms\")     plt.legend()     plt.xlabel(\"wavelength (nm)\")     plt.ylabel(\"Counts (-)\") In\u00a0[3]: Copied! <pre>for f in sequence_files:\n    file = avaread.read_file(f)\n    fig, ax = plt.subplots(2, 1)\n    ax[0].set_xlabel(\"wavelength (nm)\")\n    ax[1].set_xlabel(\"delay (ms)\")\n    fig.suptitle(f\"{file.name}: exposure: {file.exposure:.2g} ms\")\n    for a in ax:\n        a.set_ylabel(\"Counts (-)\")\n\n    for frame in file:\n        ax[0].plot(file.wavelength, frame)\n\n    ax[1].plot(file.delay, [frame.sum() for frame in file])\n    fig.tight_layout()\n</pre> for f in sequence_files:     file = avaread.read_file(f)     fig, ax = plt.subplots(2, 1)     ax[0].set_xlabel(\"wavelength (nm)\")     ax[1].set_xlabel(\"delay (ms)\")     fig.suptitle(f\"{file.name}: exposure: {file.exposure:.2g} ms\")     for a in ax:         a.set_ylabel(\"Counts (-)\")      for frame in file:         ax[0].plot(file.wavelength, frame)      ax[1].plot(file.delay, [frame.sum() for frame in file])     fig.tight_layout()"},{"location":"examples/#examples-for-using-avaread","title":"Examples for using <code>avaread</code>\u00b6","text":"<p>Below are some examples that demonstrate how to get both data and metadata from different file types using <code>avaread.read_file</code>.</p> <p>This function only takes a file path as an argument and will return an instance of either <code>avaread.AVSFile</code> or <code>avaread.STRFile</code> depending on the detected file type.</p> <p>Let's first set things up for a demonstration.</p>"},{"location":"examples/#reading-multichannel-files-raw8rir8etc","title":"Reading multichannel files (<code>*.raw8</code>,<code>*.rir8</code>,etc)\u00b6","text":"<p>Multichannel files store a spectrum from one or more devices, or channels.</p> <p>You can easily iterate over the <code>AVSFile</code> container, to access the individual <code>AVSChannel</code>s that are contained within.</p> <p>Each <code>AVSChannel</code> can have a different size sensor, exposure time, etc. and therefore stores this information itself.</p> <p>This information can be easily retrieved using attribute access (e.g. <code>channel.ID.SerialNumber</code> or <code>channel.exposure</code>).</p> <p>To access the raw data, dark and reference spectra stored for each channel, you can use the <code>scope</code>, <code>dark</code> and <code>ref</code> attributes, while the <code>signal</code> attribute returns the dark-corrected signal.</p>"},{"location":"examples/#reading-store-to-ram-files-str8etc","title":"Reading store-to-RAM files (<code>*.str8</code>,etc.)\u00b6","text":"<p>Store-to-RAM files store a series of spectra acquired by a single channel.</p> <p>Instead of multiple <code>AVSChannel</code>s nested in a <code>AVSFile</code> container, the <code>STRFile</code> object immediatly gives access to all the data.</p> <p>When you iterate over it, you iterate over the <code>frames</code> stored within.</p> <p>The metadata, such as device serial number and exposure time is the same for all frames, and therefore accesible on the <code>STFile</code> object itself.</p> <p>Each frame is simply a numpy array of data, containing the background-corrected spectrum.</p> <p>If you want the uncorrected data, it can be accessed via the <code>scope</code> attibute, similar to an <code>AVSChannel</code>.</p>"},{"location":"license/","title":"License","text":"<p>MIT License</p> <p>Copyright \u00a9 2025, Antoine Salden</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"reference/avaread/AvaTypes/","title":"AvaTypes","text":""},{"location":"reference/avaread/AvaTypes/#avaread.AvaTypes","title":"avaread.AvaTypes","text":"<p>Type definitions of mainly C Structures and Enums.</p> <p>These structures and enums respresent the way how an Avantes spectrometer interfaces with a PC, based on the SDK documentation and the <code>avaspec.h</code> header file.</p> <p>Only the types (and constants) are defined that are needed for parsing the <code>AVS</code> type files, not the complete definition from the SDK.</p> <p>In addition, a few extra Structures have been defined that aim to represent the structure of the file header for different types of file formats:</p> <ul> <li> <p>AVSPreamble: The preamble of a regular AVS file, specifying the file type and channel count.</p> </li> <li> <p>AVSInfoBlock: The header block with metadata for a spectrometer channel stored in an AVS file.</p> </li> <li> <p>STRPreamble: The preamble of a Store-to-RAM file, specifying the file type and frame count.</p> </li> <li> <p>STRInfoBlock: The header block with metadata for Store-to-RAM files.</p> </li> </ul> <p>Classes:</p> Name Description <code>DeviceStatus</code> <p>Enumeration of the different status codes for a device.</p> <code>MeasurementEnum</code> <p>Enumeration of the different measurement modes of AvaSoft.</p> <code>TrigMode</code> <p>Enumerate supported trigger modes.</p> <code>TrigSource</code> <p>Enumerate supported trigger sources.</p> <code>TrigKind</code> <p>Enumerate supported trigger types.</p> <code>MappableStructure</code> <p>A C structure with support for mapping fields to enums.</p> <code>AvsIdentityStruct</code> <p>IdentityType Structure.</p> <code>DarkCorrectionStruct</code> <p>DarkCorrectionType Structure.</p> <code>SmoothingStruct</code> <p>SmoothingType Structure.</p> <code>TriggerStruct</code> <p>TriggerType Structure.</p> <code>ControlSettingsStruct</code> <p>ControlSettingsType Structure.</p> <code>MeasConfigStruct</code> <p>MeasConfigType Structure.</p> <code>MiscInfoStruct</code> <p>A structure containing miscellaneous information stored in a file.</p> <code>AVSPreamble</code> <p>The very start if an Avantes <code>AVS</code> file that contain data from one or more spectrometers.</p> <code>AVSInfoBlock</code> <p>A metadata header for each block in a AVS file.</p> <code>STRPreamble</code> <p>The very start if an Avantes <code>STR</code> file that contains multiple spectra from a Store-to-RAM (STR) procedure.</p> <code>STRInfoBlock</code> <p>The metadata block at the start of a STR (Store-to-RAM) file, before the binary blob.</p> <p>Attributes:</p> Name Type Description <code>AVS_SERIAL_LEN</code> <code>USER_ID_LEN</code>"},{"location":"reference/avaread/AvaTypes/#avaread.AvaTypes.AVS_SERIAL_LEN","title":"AVS_SERIAL_LEN","text":"<pre><code>AVS_SERIAL_LEN = 10\n</code></pre>"},{"location":"reference/avaread/AvaTypes/#avaread.AvaTypes.USER_ID_LEN","title":"USER_ID_LEN","text":"<pre><code>USER_ID_LEN = 64\n</code></pre>"},{"location":"reference/avaread/AvaTypes/#avaread.AvaTypes.DeviceStatus","title":"DeviceStatus","text":"<p>               Bases: <code>IntEnum</code></p> <p>Enumeration of the different status codes for a device.</p> <p>Attributes:</p> Name Type Description <code>UNKNOWN</code> <code>USB_AVAILABLE</code> <code>USB_IN_USE_BY_APPLICATION</code> <code>USB_IN_USE_BY_OTHER</code> <code>ETH_AVAILABLE</code> <code>ETH_IN_USE_BY_APPLICATION</code> <code>ETH_IN_USE_BY_OTHER</code> <code>ETH_ALREADY_IN_USE_USB</code>"},{"location":"reference/avaread/AvaTypes/#avaread.AvaTypes.DeviceStatus.UNKNOWN","title":"UNKNOWN","text":"<pre><code>UNKNOWN = 0\n</code></pre>"},{"location":"reference/avaread/AvaTypes/#avaread.AvaTypes.DeviceStatus.USB_AVAILABLE","title":"USB_AVAILABLE","text":"<pre><code>USB_AVAILABLE = 1\n</code></pre>"},{"location":"reference/avaread/AvaTypes/#avaread.AvaTypes.DeviceStatus.USB_IN_USE_BY_APPLICATION","title":"USB_IN_USE_BY_APPLICATION","text":"<pre><code>USB_IN_USE_BY_APPLICATION = 2\n</code></pre>"},{"location":"reference/avaread/AvaTypes/#avaread.AvaTypes.DeviceStatus.USB_IN_USE_BY_OTHER","title":"USB_IN_USE_BY_OTHER","text":"<pre><code>USB_IN_USE_BY_OTHER = 3\n</code></pre>"},{"location":"reference/avaread/AvaTypes/#avaread.AvaTypes.DeviceStatus.ETH_AVAILABLE","title":"ETH_AVAILABLE","text":"<pre><code>ETH_AVAILABLE = 4\n</code></pre>"},{"location":"reference/avaread/AvaTypes/#avaread.AvaTypes.DeviceStatus.ETH_IN_USE_BY_APPLICATION","title":"ETH_IN_USE_BY_APPLICATION","text":"<pre><code>ETH_IN_USE_BY_APPLICATION = 5\n</code></pre>"},{"location":"reference/avaread/AvaTypes/#avaread.AvaTypes.DeviceStatus.ETH_IN_USE_BY_OTHER","title":"ETH_IN_USE_BY_OTHER","text":"<pre><code>ETH_IN_USE_BY_OTHER = 6\n</code></pre>"},{"location":"reference/avaread/AvaTypes/#avaread.AvaTypes.DeviceStatus.ETH_ALREADY_IN_USE_USB","title":"ETH_ALREADY_IN_USE_USB","text":"<pre><code>ETH_ALREADY_IN_USE_USB = 7\n</code></pre>"},{"location":"reference/avaread/AvaTypes/#avaread.AvaTypes.MeasurementEnum","title":"MeasurementEnum","text":"<p>               Bases: <code>IntEnum</code></p> <p>Enumeration of the different measurement modes of AvaSoft.</p> <p>Attributes:</p> Name Type Description <code>Scope</code> <code>ScopeDarkCorrected</code> <code>Absorbance</code> <code>Transmission</code> <code>Reflectance</code> <code>Irradiance</code> <code>RelativeIrradiance</code> <code>Temperature</code>"},{"location":"reference/avaread/AvaTypes/#avaread.AvaTypes.MeasurementEnum.Scope","title":"Scope","text":"<pre><code>Scope = 0\n</code></pre>"},{"location":"reference/avaread/AvaTypes/#avaread.AvaTypes.MeasurementEnum.ScopeDarkCorrected","title":"ScopeDarkCorrected","text":"<pre><code>ScopeDarkCorrected = 1\n</code></pre>"},{"location":"reference/avaread/AvaTypes/#avaread.AvaTypes.MeasurementEnum.Absorbance","title":"Absorbance","text":"<pre><code>Absorbance = 2\n</code></pre>"},{"location":"reference/avaread/AvaTypes/#avaread.AvaTypes.MeasurementEnum.Transmission","title":"Transmission","text":"<pre><code>Transmission = 3\n</code></pre>"},{"location":"reference/avaread/AvaTypes/#avaread.AvaTypes.MeasurementEnum.Reflectance","title":"Reflectance","text":"<pre><code>Reflectance = 4\n</code></pre>"},{"location":"reference/avaread/AvaTypes/#avaread.AvaTypes.MeasurementEnum.Irradiance","title":"Irradiance","text":"<pre><code>Irradiance = 5\n</code></pre>"},{"location":"reference/avaread/AvaTypes/#avaread.AvaTypes.MeasurementEnum.RelativeIrradiance","title":"RelativeIrradiance","text":"<pre><code>RelativeIrradiance = 6\n</code></pre>"},{"location":"reference/avaread/AvaTypes/#avaread.AvaTypes.MeasurementEnum.Temperature","title":"Temperature","text":"<pre><code>Temperature = 7\n</code></pre>"},{"location":"reference/avaread/AvaTypes/#avaread.AvaTypes.TrigMode","title":"TrigMode","text":"<p>               Bases: <code>IntEnum</code></p> <p>Enumerate supported trigger modes.</p> <p>Attributes:</p> Name Type Description <code>SW</code> <code>HW</code>"},{"location":"reference/avaread/AvaTypes/#avaread.AvaTypes.TrigMode.SW","title":"SW","text":"<pre><code>SW = 0\n</code></pre>"},{"location":"reference/avaread/AvaTypes/#avaread.AvaTypes.TrigMode.HW","title":"HW","text":"<pre><code>HW = 1\n</code></pre>"},{"location":"reference/avaread/AvaTypes/#avaread.AvaTypes.TrigSource","title":"TrigSource","text":"<p>               Bases: <code>IntEnum</code></p> <p>Enumerate supported trigger sources.</p> <p>Attributes:</p> Name Type Description <code>SINGLE</code> <code>EXT</code> <code>SYNC</code>"},{"location":"reference/avaread/AvaTypes/#avaread.AvaTypes.TrigSource.SINGLE","title":"SINGLE","text":"<pre><code>SINGLE = 2\n</code></pre>"},{"location":"reference/avaread/AvaTypes/#avaread.AvaTypes.TrigSource.EXT","title":"EXT","text":"<pre><code>EXT = 0\n</code></pre>"},{"location":"reference/avaread/AvaTypes/#avaread.AvaTypes.TrigSource.SYNC","title":"SYNC","text":"<pre><code>SYNC = 1\n</code></pre>"},{"location":"reference/avaread/AvaTypes/#avaread.AvaTypes.TrigKind","title":"TrigKind","text":"<p>               Bases: <code>IntEnum</code></p> <p>Enumerate supported trigger types.</p> <p>Attributes:</p> Name Type Description <code>EDGE</code> <code>LEVEL</code>"},{"location":"reference/avaread/AvaTypes/#avaread.AvaTypes.TrigKind.EDGE","title":"EDGE","text":"<pre><code>EDGE = 0\n</code></pre>"},{"location":"reference/avaread/AvaTypes/#avaread.AvaTypes.TrigKind.LEVEL","title":"LEVEL","text":"<pre><code>LEVEL = 1\n</code></pre>"},{"location":"reference/avaread/AvaTypes/#avaread.AvaTypes.MappableStructure","title":"MappableStructure","text":"<p>               Bases: <code>Structure</code></p> <p>A C structure with support for mapping fields to enums.</p>"},{"location":"reference/avaread/AvaTypes/#avaread.AvaTypes.MappableStructure._pack_","title":"_pack_","text":"<pre><code>_pack_: int = 1\n</code></pre>"},{"location":"reference/avaread/AvaTypes/#avaread.AvaTypes.MappableStructure._fields_","title":"_fields_","text":"<pre><code>_fields_: list[tuple[str, Any]] = []\n</code></pre>"},{"location":"reference/avaread/AvaTypes/#avaread.AvaTypes.MappableStructure._map","title":"_map","text":"<pre><code>_map: dict = {}\n</code></pre>"},{"location":"reference/avaread/AvaTypes/#avaread.AvaTypes.AvsIdentityStruct","title":"AvsIdentityStruct","text":"<p>               Bases: <code>MappableStructure</code></p> <p>IdentityType Structure.</p>"},{"location":"reference/avaread/AvaTypes/#avaread.AvaTypes.AvsIdentityStruct._pack_","title":"_pack_","text":"<pre><code>_pack_ = 1\n</code></pre>"},{"location":"reference/avaread/AvaTypes/#avaread.AvaTypes.AvsIdentityStruct._fields_","title":"_fields_","text":"<pre><code>_fields_ = [('SerialNumber', c_char * AVS_SERIAL_LEN), ('UserFriendlyName', c_char * USER_ID_LEN), ('Status', c_ubyte)]\n</code></pre>"},{"location":"reference/avaread/AvaTypes/#avaread.AvaTypes.AvsIdentityStruct._map","title":"_map","text":"<pre><code>_map = {'Status': DeviceStatus}\n</code></pre>"},{"location":"reference/avaread/AvaTypes/#avaread.AvaTypes.DarkCorrectionStruct","title":"DarkCorrectionStruct","text":"<p>               Bases: <code>MappableStructure</code></p> <p>DarkCorrectionType Structure.</p>"},{"location":"reference/avaread/AvaTypes/#avaread.AvaTypes.DarkCorrectionStruct._pack_","title":"_pack_","text":"<pre><code>_pack_ = 1\n</code></pre>"},{"location":"reference/avaread/AvaTypes/#avaread.AvaTypes.DarkCorrectionStruct._fields_","title":"_fields_","text":"<pre><code>_fields_ = [('Enable', c_ubyte), ('ForgetPercentage', c_ubyte)]\n</code></pre>"},{"location":"reference/avaread/AvaTypes/#avaread.AvaTypes.SmoothingStruct","title":"SmoothingStruct","text":"<p>               Bases: <code>MappableStructure</code></p> <p>SmoothingType Structure.</p>"},{"location":"reference/avaread/AvaTypes/#avaread.AvaTypes.SmoothingStruct._pack_","title":"_pack_","text":"<pre><code>_pack_ = 1\n</code></pre>"},{"location":"reference/avaread/AvaTypes/#avaread.AvaTypes.SmoothingStruct._fields_","title":"_fields_","text":"<pre><code>_fields_ = [('SmoothPix', c_uint16), ('SmoothModel', c_ubyte)]\n</code></pre>"},{"location":"reference/avaread/AvaTypes/#avaread.AvaTypes.TriggerStruct","title":"TriggerStruct","text":"<p>               Bases: <code>MappableStructure</code></p> <p>TriggerType Structure.</p>"},{"location":"reference/avaread/AvaTypes/#avaread.AvaTypes.TriggerStruct._pack_","title":"_pack_","text":"<pre><code>_pack_ = 1\n</code></pre>"},{"location":"reference/avaread/AvaTypes/#avaread.AvaTypes.TriggerStruct._fields_","title":"_fields_","text":"<pre><code>_fields_ = [('Mode', c_ubyte), ('Source', c_ubyte), ('SourceType', c_ubyte)]\n</code></pre>"},{"location":"reference/avaread/AvaTypes/#avaread.AvaTypes.TriggerStruct._map","title":"_map","text":"<pre><code>_map = {'Mode': TrigMode, 'Source': TrigSource, 'SourceType': TrigKind}\n</code></pre>"},{"location":"reference/avaread/AvaTypes/#avaread.AvaTypes.ControlSettingsStruct","title":"ControlSettingsStruct","text":"<p>               Bases: <code>MappableStructure</code></p> <p>ControlSettingsType Structure.</p>"},{"location":"reference/avaread/AvaTypes/#avaread.AvaTypes.ControlSettingsStruct._pack_","title":"_pack_","text":"<pre><code>_pack_ = 1\n</code></pre>"},{"location":"reference/avaread/AvaTypes/#avaread.AvaTypes.ControlSettingsStruct._fields_","title":"_fields_","text":"<pre><code>_fields_ = [\n    (\"StrobeControl\", c_uint16),\n    (\"LaserDelay\", c_uint32),\n    (\"LaserWidth\", c_uint32),\n    (\"LaserWaveLength\", c_float),\n    (\"StoreToRam\", c_uint16),\n]\n</code></pre>"},{"location":"reference/avaread/AvaTypes/#avaread.AvaTypes.MeasConfigStruct","title":"MeasConfigStruct","text":"<p>               Bases: <code>MappableStructure</code></p> <p>MeasConfigType Structure.</p>"},{"location":"reference/avaread/AvaTypes/#avaread.AvaTypes.MeasConfigStruct._pack_","title":"_pack_","text":"<pre><code>_pack_ = 1\n</code></pre>"},{"location":"reference/avaread/AvaTypes/#avaread.AvaTypes.MeasConfigStruct._fields_","title":"_fields_","text":"<pre><code>_fields_ = [\n    (\"StartPixel\", c_uint16),\n    (\"StopPixel\", c_uint16),\n    (\"IntegrationTime\", c_float),\n    (\"IntegrationDelay\", c_uint32),\n    (\"NrAverages\", c_uint32),\n    (\"CorDynDark\", DarkCorrectionStruct),\n    (\"Smoothing\", SmoothingStruct),\n    (\"SaturationDetection\", c_ubyte),\n    (\"Trigger\", TriggerStruct),\n    (\"Control\", ControlSettingsStruct),\n]\n</code></pre>"},{"location":"reference/avaread/AvaTypes/#avaread.AvaTypes.MiscInfoStruct","title":"MiscInfoStruct","text":"<p>               Bases: <code>MappableStructure</code></p> <p>A structure containing miscellaneous information stored in a file.</p> <p>This block of fields can be found both in AVS and STR files, but is not defined or documented for the AvaSDK.</p>"},{"location":"reference/avaread/AvaTypes/#avaread.AvaTypes.MiscInfoStruct._fields_","title":"_fields_","text":"<pre><code>_fields_ = [\n    (\"file_datetime\", c_uint32),\n    (\"detectorTemp\", c_float),\n    (\"boardTemp\", c_float),\n    (\"skip_float\", c_float),\n    (\"ColorTemperature\", c_float),\n    (\"CalIntTime\", c_float),\n]\n</code></pre>"},{"location":"reference/avaread/AvaTypes/#avaread.AvaTypes.AVSPreamble","title":"AVSPreamble","text":"<p>               Bases: <code>MappableStructure</code></p> <p>The very start if an Avantes <code>AVS</code> file that contain data from one or more spectrometers.</p> <p>This header contains information on the file type, file version and amount of channels.</p> <p>Note that all files that start with the <code>AVS</code> magic bytes are supported, this corresponds to all 'regular' files being supported.</p> <p>STR (Store-to-RAM) files have a different preamble.</p>"},{"location":"reference/avaread/AvaTypes/#avaread.AvaTypes.AVSPreamble._fields_","title":"_fields_","text":"<pre><code>_fields_ = [('FileType', c_char * 3), ('Version', c_char * 2), ('channels', c_ubyte)]\n</code></pre>"},{"location":"reference/avaread/AvaTypes/#avaread.AvaTypes.AVSInfoBlock","title":"AVSInfoBlock","text":"<p>               Bases: <code>MappableStructure</code></p> <p>A metadata header for each block in a AVS file.</p> <p>This header corresponds to a single spectrometer, or spectrometer channel (for a multi channel device).</p>"},{"location":"reference/avaread/AvaTypes/#avaread.AvaTypes.AVSInfoBlock._fields_","title":"_fields_","text":"<pre><code>_fields_ = [\n    (\"blockLength\", c_uint16),\n    (\"Unused1\", c_byte * 2),\n    (\"channelIndex\", c_byte),\n    (\"measurementEnum\", c_ubyte),\n    (\"Unused2\", c_byte * 2),\n    (\"ID\", AvsIdentityStruct),\n    (\"Measurement\", MeasConfigStruct),\n    (\"timestamp\", c_uint32),\n    (\"Misc\", MiscInfoStruct),\n    (\"aFit\", c_double * 5),\n    (\"comment\", c_char * 130),\n]\n</code></pre>"},{"location":"reference/avaread/AvaTypes/#avaread.AvaTypes.AVSInfoBlock._map","title":"_map","text":"<pre><code>_map = {'measurementEnum': MeasurementEnum}\n</code></pre>"},{"location":"reference/avaread/AvaTypes/#avaread.AvaTypes.STRPreamble","title":"STRPreamble","text":"<p>               Bases: <code>MappableStructure</code></p> <p>The very start if an Avantes <code>STR</code> file that contains multiple spectra from a Store-to-RAM (STR) procedure.</p> <p>This header contains information on the file type, file version and amount of frames.</p> <p>Note that all files that start with the <code>STR</code> magic bytes are supported.</p> <p>Regular AVS files have a slightly different preamble.</p>"},{"location":"reference/avaread/AvaTypes/#avaread.AvaTypes.STRPreamble._fields_","title":"_fields_","text":"<pre><code>_fields_ = [('FileType', c_char * 3), ('Version', c_char * 2), ('frames', c_uint16)]\n</code></pre>"},{"location":"reference/avaread/AvaTypes/#avaread.AvaTypes.STRInfoBlock","title":"STRInfoBlock","text":"<p>               Bases: <code>MappableStructure</code></p> <p>The metadata block at the start of a STR (Store-to-RAM) file, before the binary blob.</p> <p>This header corresponds to a single spectrometer, or spectrometer channel, but describes a sequence of spectra/frames stored in a STR procedure.</p>"},{"location":"reference/avaread/AvaTypes/#avaread.AvaTypes.STRInfoBlock._fields_","title":"_fields_","text":"<pre><code>_fields_ = [\n    (\"Unused\", c_byte * 5),\n    (\"ID\", AvsIdentityStruct),\n    (\"Measurement\", MeasConfigStruct),\n    (\"Unused1\", c_byte * 7),\n    (\"Misc\", MiscInfoStruct),\n    (\"Unused2\", c_byte * 47),\n    (\"comment\", c_char * 130),\n]\n</code></pre>"},{"location":"reference/avaread/","title":"avaread","text":""},{"location":"reference/avaread/#avaread","title":"avaread","text":"<p>Avaread is a package that provides methods for reading Avantes AvaSoft files.</p> <p>It supports both 'regular' files, as well as STR (Store-to-RAM) files.</p> <p>Modules:</p> Name Description <code>AvaTypes</code> <p>Type definitions of mainly C Structures and Enums.</p> <code>reader</code> <p>A module containing the actual logic for reading Avantes AvaSoft files.</p> <p>Functions:</p> Name Description <code>read_file</code> <p>Open a file saved by Avantes AvaSoft.</p>"},{"location":"reference/avaread/#avaread.read_file","title":"read_file","text":"<pre><code>read_file(file_path: Path) -&gt; AVSFile | STRFile\n</code></pre> <p>Open a file saved by Avantes AvaSoft.</p> <p>Detects the file type from the file and returns a corresponding instance of <code>AVSFile</code> or <code>STRFile</code>.</p> Source code in <code>src/avaread/reader.py</code> <pre><code>def read_file(file_path: Path) -&gt; AVSFile | STRFile:\n    \"\"\"Open a file saved by Avantes AvaSoft.\n\n    Detects the file type from the file and returns a corresponding instance of [`AVSFile`][(m).AVSFile] or [`STRFile`][(m).STRFile].\n    \"\"\"\n    file_path = Path(file_path)\n    if not file_path.exists():\n        raise FileNotFoundError(f\"{file_path} does not exist\")\n    elif file_path.is_dir():\n        raise FileNotFoundError(f\"{file_path} is a directory, please provide a file path\")\n    with file_path.open(\"rb\") as fo:\n        prelude = fo.read(5)\n    file_format = prelude[:3].decode()\n    file_version = int(prelude[3:5]) / 10\n    if file_format.upper() == \"AVS\":\n        if file_version &lt; 8:\n            raise AvaReadException(f\"File version {file_version} is not supported.\")\n        return AVSFile(file_path)\n    elif file_format.upper() == \"STR\":\n        if file_version &lt; 8:\n            raise AvaReadException(f\"File version {file_version} is not supported.\")\n        return STRFile(file_path)\n    else:\n        raise AvaReadException(f\"{file_path.name} is not a valid Avantes AvaSoft 8 file.\")\n</code></pre>"},{"location":"reference/avaread/reader/","title":"reader","text":""},{"location":"reference/avaread/reader/#avaread.reader","title":"avaread.reader","text":"<p>A module containing the actual logic for reading Avantes AvaSoft files.</p> <p>Classes:</p> Name Description <code>AvaReadException</code> <p>Exception thrown when there are problems when reading a file.</p> <code>StructMapping</code> <p>Object to map the contents of a C structure to more python-native objects.</p> <code>AVSChannel</code> <p>Represents data and metadata header of an Avantes spectrometer channel.</p> <code>AVSFile</code> <p>A file in Avantes <code>AVS</code> format, containing data from one or more channels.</p> <code>STRFile</code> <p>A Store-to-RAM (STR) file.</p> <p>Functions:</p> Name Description <code>read_file</code> <p>Open a file saved by Avantes AvaSoft.</p>"},{"location":"reference/avaread/reader/#avaread.reader.AvaReadException","title":"AvaReadException","text":"<p>               Bases: <code>BaseException</code></p> <p>Exception thrown when there are problems when reading a file.</p>"},{"location":"reference/avaread/reader/#avaread.reader.StructMapping","title":"StructMapping","text":"<pre><code>StructMapping(struct: MappableStructure)\n</code></pre> <p>Object to map the contents of a C structure to more python-native objects.</p> <p>Enum values will be mapped to the appropriate enums (if set in the <code>MappableStructure._map</code> attribute), while numeric arrays will use numpy arrays, and <code>char</code> arrays become strings.</p> <p>This mapping will happen each time an attribute is accessed, which means it will reflect changes made to the content of the underlying struct.</p> <p>You should not use this class to modify attributes, rather you should update the underlying struct(s) itself.</p> <p>The main purpose is to map (nested) structures to types that are easier to work with and represent in Python.</p> <p>Methods:</p> Name Description <code>print</code> <p>Print the contents of the underlying struct by traversing it's hierarchy.</p> <p>Attributes:</p> Name Type Description <code>fields</code> <code>struct</code> Source code in <code>src/avaread/reader.py</code> <pre><code>def __init__(self, struct: MappableStructure):\n    \"\"\"Create a shallow proxy object for a [`MappableStructure`][(p).AvaTypes.MappableStructure] that maps the contents to python native types.\"\"\"\n    self._name = struct.__class__.__name__\n    self.fields = [n for n, _ in struct._fields_]\n    self.struct = struct\n</code></pre>"},{"location":"reference/avaread/reader/#avaread.reader.StructMapping._name","title":"_name","text":"<pre><code>_name = __name__\n</code></pre>"},{"location":"reference/avaread/reader/#avaread.reader.StructMapping.fields","title":"fields","text":"<pre><code>fields = [n for n, _ in (_fields_)]\n</code></pre>"},{"location":"reference/avaread/reader/#avaread.reader.StructMapping.struct","title":"struct","text":"<pre><code>struct = struct\n</code></pre>"},{"location":"reference/avaread/reader/#avaread.reader.StructMapping.print","title":"print","text":"<pre><code>print(prefix: str = '')\n</code></pre> <p>Print the contents of the underlying struct by traversing it's hierarchy.</p> <p>Parameters:</p> Name Type Description Default <code>prefix</code> <code>str</code> <p>String to use when creating the full name of a field., mainly used for resolving field names in nested hierarchies. Default: \"\"</p> <code>''</code> Source code in <code>src/avaread/reader.py</code> <pre><code>def print(self, prefix: str = \"\"):\n    \"\"\"Print the contents of the underlying struct by traversing it's hierarchy.\n\n    Args:\n        prefix:   String to use when creating the full name of a field., mainly used for resolving field names in nested hierarchies. Default: \"\"\n    \"\"\"\n    for name, _dtype in self.struct._fields_:\n        full_name = f\"{prefix}.{name}\".strip(\".\")\n        prop = getattr(self, name)\n        if isinstance(prop, StructMapping):\n            prop.print(prefix=full_name)\n        elif isinstance(prop, IntEnum):\n            print(full_name, prop.__repr__())\n        else:\n            print(full_name, prop)\n</code></pre>"},{"location":"reference/avaread/reader/#avaread.reader.AVSChannel","title":"AVSChannel","text":"<pre><code>AVSChannel(header: AVSInfoBlock, data: NDArray[float32])\n</code></pre> <p>Represents data and metadata header of an Avantes spectrometer channel.</p> <p>Each <code>AVSFile</code> can stores one or more blocks containing this information, one for each channel/spectrometer.</p> <p>To access the data you can use the following attibutes: <code>scope</code> corresponds to the raw signal, <code>dark</code> to the associated background signal, and <code>ref</code> to a reference signal.</p> <p>In addition, the <code>data</code> attribute gives you the array of all these signals together.</p> <p>Parameters:</p> Name Type Description Default <code>header</code> <code>AVSInfoBlock</code> <p>A C Structure containing channel-specific metadata.</p> required <code>data</code> <code>NDArray[float32]</code> <p>A 2D array with columns in the order [<code>wavelength</code>,<code>scope</code>,<code>dark</code>,<code>reference</code>]</p> required <p>Methods:</p> Name Description <code>from_buffer</code> <p>Read the binary data for a channel from an opened file handle.</p> <p>Attributes:</p> Name Type Description <code>PADDING</code> <p>A padding of 10 bytes between consecutive blocks of channel data.</p> <code>data</code> <code>serial</code> <p>The serial number of the spectrometer.</p> <code>date</code> <p>The date the spectrum was stored.</p> <code>pixels</code> <p>Return the amount of active pixels of the acquisition.</p> <code>exposure</code> <p>The exposure time used in milliseconds.</p> <code>wavelength</code> <p>The wavelengths corresponding the the pixels of the detector of the spectrometer.</p> <code>scope</code> <p>The raw signal from the spectrometer, as stored in the file.</p> <code>dark</code> <p>The 'dark' signal of the spectrometer, as stored in the file.</p> <code>ref</code> <p>The 'reference' signal of the spectrometer as stored in the file.</p> <code>signal</code> <p>The 'signal' of the spectrometer, computed from the raw signal minus dark signal.</p> Source code in <code>src/avaread/reader.py</code> <pre><code>def __init__(self, header: AVSInfoBlock, data: NDArray[np.float32]):\n    \"\"\"Instantiate a `AVSChannel` from a header (which contain metadata) and data.\n\n    To access the data you can use the following attibutes:\n    [`scope`][..] corresponds to the raw signal, [`dark`][..] to the associated background signal, and [`ref`][..] to a reference signal.\n\n    In addition, the [`data`][..] attribute gives you the array of all these signals together.\n\n    Arguments:\n        header:     A C Structure containing channel-specific metadata.\n        data:       A 2D array with columns in the order [`wavelength`,`scope`,`dark`,`reference`]\n\n\n    \"\"\"\n    self._mapping = StructMapping(header)\n    self.data = data\n</code></pre>"},{"location":"reference/avaread/reader/#avaread.reader.AVSChannel.PADDING","title":"PADDING","text":"<pre><code>PADDING = 10\n</code></pre> <p>A padding of 10 bytes between consecutive blocks of channel data.</p>"},{"location":"reference/avaread/reader/#avaread.reader.AVSChannel._mapping","title":"_mapping","text":"<pre><code>_mapping = StructMapping(header)\n</code></pre>"},{"location":"reference/avaread/reader/#avaread.reader.AVSChannel.data","title":"data","text":"<pre><code>data = data\n</code></pre>"},{"location":"reference/avaread/reader/#avaread.reader.AVSChannel.serial","title":"serial","text":"<pre><code>serial\n</code></pre> <p>The serial number of the spectrometer.</p>"},{"location":"reference/avaread/reader/#avaread.reader.AVSChannel.date","title":"date","text":"<pre><code>date\n</code></pre> <p>The date the spectrum was stored.</p>"},{"location":"reference/avaread/reader/#avaread.reader.AVSChannel.pixels","title":"pixels","text":"<pre><code>pixels\n</code></pre> <p>Return the amount of active pixels of the acquisition.</p> Note <p>This can be different from the total pixel count of the sensor if some pixels are deactivated.</p>"},{"location":"reference/avaread/reader/#avaread.reader.AVSChannel.exposure","title":"exposure","text":"<pre><code>exposure\n</code></pre> <p>The exposure time used in milliseconds.</p> <p>Sometimes also called <code>integration time</code> of the sensor.</p>"},{"location":"reference/avaread/reader/#avaread.reader.AVSChannel.wavelength","title":"wavelength","text":"<pre><code>wavelength\n</code></pre> <p>The wavelengths corresponding the the pixels of the detector of the spectrometer.</p> <p>The values of this pixel-to-wavelength mapping come from the calibration polynomial.</p>"},{"location":"reference/avaread/reader/#avaread.reader.AVSChannel.scope","title":"scope","text":"<pre><code>scope\n</code></pre> <p>The raw signal from the spectrometer, as stored in the file.</p> <p>Called the 'Scope' data (or RawScope) by Avantes.</p>"},{"location":"reference/avaread/reader/#avaread.reader.AVSChannel.dark","title":"dark","text":"<pre><code>dark\n</code></pre> <p>The 'dark' signal of the spectrometer, as stored in the file.</p>"},{"location":"reference/avaread/reader/#avaread.reader.AVSChannel.ref","title":"ref","text":"<pre><code>ref\n</code></pre> <p>The 'reference' signal of the spectrometer as stored in the file.</p>"},{"location":"reference/avaread/reader/#avaread.reader.AVSChannel.signal","title":"signal","text":"<pre><code>signal\n</code></pre> <p>The 'signal' of the spectrometer, computed from the raw signal minus dark signal.</p>"},{"location":"reference/avaread/reader/#avaread.reader.AVSChannel.from_buffer","title":"from_buffer","text":"<pre><code>from_buffer(buffer, offset=0)\n</code></pre> <p>Read the binary data for a channel from an opened file handle.</p> <p>Each block of binary data has an empty padding of 3779 bytes it seems, plus <code>PADDING</code>, between each channel binary block.</p> Source code in <code>src/avaread/reader.py</code> <pre><code>@classmethod\ndef from_buffer(cls, buffer, offset=0):\n    \"\"\"Read the binary data for a channel from an opened file handle.\n\n    Each block of binary data has an empty padding of 3779 bytes it seems, plus [`PADDING`][..], between each channel binary block.\n    \"\"\"\n    startBlock = buffer.tell()\n    header = AVSInfoBlock()\n    buffer.seek(offset, os.SEEK_CUR)\n    buffer.readinto(header)\n    num_pixels = header.Measurement.StopPixel - header.Measurement.StartPixel + 1\n    # TODO: check if we need to account for start pixel being not the 0th pixel, thus needing to offset the read into the block.\n    # It does not appear we read a pixel count, only start and stop pixels, thus don't know the size of the array/block.\n    data = np.fromfile(buffer, dtype=np.float32, count=int(4 * num_pixels)).reshape(4, -1).T\n    # endData = buffer.tell()\n    # print(f\"{endData=},{startBlock+header.blockLength-endData=}\")\n    # TODO: Check if this padding has a role, or is just padding\n    buffer.seek(startBlock + header.blockLength + cls.PADDING)\n    return AVSChannel(header, data)\n</code></pre>"},{"location":"reference/avaread/reader/#avaread.reader.AVSFile","title":"AVSFile","text":"<pre><code>AVSFile(path: Path | str)\n</code></pre> <p>A file in Avantes <code>AVS</code> format, containing data from one or more channels.</p> <p>Each AVSFile will contain one or more <code>AVSChannels</code>.</p> <p>These can be accessed via the <code>channels</code> attribute, which is a list of <code>AVSChannel</code>s.</p> <p>Alternatively, you can access the channels by index, like a list, or by the serial number of the channel, like a dict.</p> <p>Example: <pre><code>file_name = pathlib.Path(\"./some_spectrum.raw8`) # a file with one or more channels\n\ndata = AVSFile(file_name)\n\nfor enumerate(spectrum) in data:\n    print(spectrum)\n    assert spectrum == data.channels[i] # access via the `channels` attribute is equivalent\n\nserial = data.channels[0].serial\n# all below ways of access are equivalent, you can access by index (like a list), or by key (like a dict)\nassert data[0] == data.channels[0] == data[serial]\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path | str</code> <p>A file path to an <code>AVS</code> file.</p> required <p>Attributes:</p> Name Type Description <code>path</code> <code>preamble</code> <code>channels</code> <code>list[AVSChannel]</code> <code>name</code> <p>The name of the file.</p> <code>date</code> <p>The date that the file was stored on.</p> Source code in <code>src/avaread/reader.py</code> <pre><code>def __init__(self, path: Path | str):\n    \"\"\"Read a AVS file from disk and create an object that can be used to easily acces the (meta)data.\n\n    Each AVSFile will contain one or more [`AVSChannels`][(m).AVSChannel].\n\n    These can be accessed via the [`channels`][(c).] attribute, which is a list of [`AVSChannel`][(m).AVSChannel]s.\n\n    Alternatively, you can access the channels by index, like a list, or by the serial number of the channel, like a dict.\n\n    Example:\n    ```python\n    file_name = pathlib.Path(\"./some_spectrum.raw8`) # a file with one or more channels\n\n    data = AVSFile(file_name)\n\n    for enumerate(spectrum) in data:\n        print(spectrum)\n        assert spectrum == data.channels[i] # access via the `channels` attribute is equivalent\n\n    serial = data.channels[0].serial\n    # all below ways of access are equivalent, you can access by index (like a list), or by key (like a dict)\n    assert data[0] == data.channels[0] == data[serial]\n    ```\n\n    Args:\n        path (Path|str): A file path to an `AVS` file.\n    \"\"\"\n    self.path = Path(path).resolve()\n    with self.path.open(\"rb\") as fo:\n        self.preamble = AVSPreamble()\n        fo.readinto(self.preamble)\n        if self.preamble.FileType != b\"AVS\":\n            # Raise error when magic bytes mismatch\n            raise AvaReadException(f\"{self.path.name} is not a valid Avantes `AVS` file.\")\n        # TODO: maybe a version check?\n        self.channels: list[AVSChannel] = [AVSChannel.from_buffer(fo) for _ in range(self.preamble.channels)]\n</code></pre>"},{"location":"reference/avaread/reader/#avaread.reader.AVSFile.path","title":"path","text":"<pre><code>path = resolve()\n</code></pre>"},{"location":"reference/avaread/reader/#avaread.reader.AVSFile.preamble","title":"preamble","text":"<pre><code>preamble = AVSPreamble()\n</code></pre>"},{"location":"reference/avaread/reader/#avaread.reader.AVSFile.channels","title":"channels","text":"<pre><code>channels: list[AVSChannel] = [(from_buffer(fo)) for _ in (range(channels))]\n</code></pre>"},{"location":"reference/avaread/reader/#avaread.reader.AVSFile.name","title":"name","text":"<pre><code>name\n</code></pre> <p>The name of the file.</p>"},{"location":"reference/avaread/reader/#avaread.reader.AVSFile.date","title":"date","text":"<pre><code>date\n</code></pre> <p>The date that the file was stored on.</p>"},{"location":"reference/avaread/reader/#avaread.reader.STRFile","title":"STRFile","text":"<pre><code>STRFile(path: Path)\n</code></pre> <p>A Store-to-RAM (STR) file.</p> <p>These STR files store multiple frames acquired by a single channel, i.e. a kinetic series, or a time-lapse.</p> <p>Instead of an <code>AVSFile</code>, these files store data for a single channel, but multiple <code>frames</code> in sequence.</p> <p>The raw signals for all frames are stored in the data attribute as a numpy array.</p> <p>This array has the shape (pixels, frames), where pixels is the full size of the used CCD sensor.</p> <p>If the data was acquired with a smaller region on the sensor active, the inactive pixels will contain zeros.</p> <p>The attributes <code>scope</code>, <code>dark</code>, <code>ref</code>, and <code>signal</code> all conveniently return only the active part of the array.</p> <p>In addition, you can iterate over an <code>STRFile</code> to get the background-corrected data on a per-frame basis, or use access-by-index.</p> <p>Example: <pre><code>file = pathlib.Path(\"./some_str_file.str\")\nspectra = STRFile(file)\n\nfor i,frame in enumerate(spectra):\n    plt.plot(spectra.wavelength, frame, label=f\"Frame: {i}\")\n\nplt.legend()\n</code></pre></p> <p>Attributes:</p> Name Type Description <code>preamble</code> <code>path</code> <code>delay</code> <code>data</code> <code>serial</code> <p>The serial of the spectrometer.</p> <code>name</code> <p>The name of the file, including extension.</p> <code>frames</code> <code>int</code> <p>Return the amount of frames stored in the file.</p> <code>pixels</code> <p>Return the amount of active pixels of the acquisition.</p> <code>exposure</code> <p>The exposure time used in milliseconds.</p> <code>wavelength</code> <p>Return the wavelength array, constrained to the range of active pixels.</p> <code>scope</code> <p>The raw signal from the spectrometer, as stored in the file.</p> <code>dark</code> <p>Return the Dark signal array (or background), constrained to the range of active pixels.</p> <code>ref</code> <p>Return the Reference signal array, constrained to the range of active pixels.</p> <code>signal</code> <p>Return the dark-corrected signal for all frames, constrained to the range of active pixels.</p> Source code in <code>src/avaread/reader.py</code> <pre><code>def __init__(self, path: Path):\n    \"\"\"Read a STR file from disk and create an object that can be used to easily acces the (meta)data.\"\"\"\n    self.preamble = STRPreamble()\n    self._header = STRInfoBlock()\n    self._mapping = StructMapping(self._header)\n    self.path = Path(path).resolve()\n    with self.path.open(\"rb\") as fo:\n        fo.readinto(self.preamble)\n        if self.preamble.FileType != b\"STR\":\n            # Raise error when magic bytes mismatch; must be `STR`\n            raise AvaReadException(f\"{self.path.name} is not a valid Avantes `STR` file.\")\n        fo.readinto(self._header)\n        fo.seek(10000)  # Header plus a reserved (or padding) block always seems to be 10000 bytes.\n        pixels, *_ = struct.unpack(\n            \"&lt;hbhb\", fo.read(6)\n        )  # appears this block contains: (pixels, somevalue1, pixels, somevalue2)\n        # next is some block of mysterious values of type double,but of value `1`. Some flag?\n        # values = np.fromfile(fo, dtype=np.double, count = pixels)\n        fo.seek(int(pixels * sizeof(c_double)), os.SEEK_CUR)  # skip for now\n        self._wavelength = np.fromfile(fo, dtype=np.double, count=pixels)\n        self._dark = np.fromfile(fo, dtype=np.double, count=pixels)\n        self._ref = np.fromfile(fo, dtype=np.double, count=pixels)\n        self.delay = np.zeros(self.preamble.frames)\n        self.data = np.zeros((pixels, self.preamble.frames), dtype=np.double)\n        stride = pixels * sizeof(c_double)  # noqa: F841\n        for i in range(self.preamble.frames):\n            self.delay[i] = struct.unpack(\"l\", fo.read(sizeof(c_long)))[0] / 100  # `unpack` return tuple\n            self.data[:, i] = np.fromfile(fo, dtype=np.double, count=pixels)\n</code></pre>"},{"location":"reference/avaread/reader/#avaread.reader.STRFile.preamble","title":"preamble","text":"<pre><code>preamble = STRPreamble()\n</code></pre>"},{"location":"reference/avaread/reader/#avaread.reader.STRFile._header","title":"_header","text":"<pre><code>_header = STRInfoBlock()\n</code></pre>"},{"location":"reference/avaread/reader/#avaread.reader.STRFile._mapping","title":"_mapping","text":"<pre><code>_mapping = StructMapping(_header)\n</code></pre>"},{"location":"reference/avaread/reader/#avaread.reader.STRFile.path","title":"path","text":"<pre><code>path = resolve()\n</code></pre>"},{"location":"reference/avaread/reader/#avaread.reader.STRFile._wavelength","title":"_wavelength","text":"<pre><code>_wavelength = fromfile(fo, dtype=double, count=pixels)\n</code></pre>"},{"location":"reference/avaread/reader/#avaread.reader.STRFile._dark","title":"_dark","text":"<pre><code>_dark = fromfile(fo, dtype=double, count=pixels)\n</code></pre>"},{"location":"reference/avaread/reader/#avaread.reader.STRFile._ref","title":"_ref","text":"<pre><code>_ref = fromfile(fo, dtype=double, count=pixels)\n</code></pre>"},{"location":"reference/avaread/reader/#avaread.reader.STRFile.delay","title":"delay","text":"<pre><code>delay = zeros(frames)\n</code></pre>"},{"location":"reference/avaread/reader/#avaread.reader.STRFile.data","title":"data","text":"<pre><code>data = zeros((pixels, frames), dtype=double)\n</code></pre>"},{"location":"reference/avaread/reader/#avaread.reader.STRFile.serial","title":"serial","text":"<pre><code>serial\n</code></pre> <p>The serial of the spectrometer.</p>"},{"location":"reference/avaread/reader/#avaread.reader.STRFile.name","title":"name","text":"<pre><code>name\n</code></pre> <p>The name of the file, including extension.</p>"},{"location":"reference/avaread/reader/#avaread.reader.STRFile.frames","title":"frames","text":"<pre><code>frames: int\n</code></pre> <p>Return the amount of frames stored in the file.</p>"},{"location":"reference/avaread/reader/#avaread.reader.STRFile.pixels","title":"pixels","text":"<pre><code>pixels\n</code></pre> <p>Return the amount of active pixels of the acquisition.</p> Note <p>This can be different from the total pixel count of the sensor if some pixels are deactivated.</p>"},{"location":"reference/avaread/reader/#avaread.reader.STRFile.exposure","title":"exposure","text":"<pre><code>exposure\n</code></pre> <p>The exposure time used in milliseconds.</p> <p>Sometimes also called <code>integration time</code> of the sensor.</p>"},{"location":"reference/avaread/reader/#avaread.reader.STRFile.wavelength","title":"wavelength","text":"<pre><code>wavelength\n</code></pre> <p>Return the wavelength array, constrained to the range of active pixels.</p>"},{"location":"reference/avaread/reader/#avaread.reader.STRFile.scope","title":"scope","text":"<pre><code>scope\n</code></pre> <p>The raw signal from the spectrometer, as stored in the file.</p> <p>Called the 'Scope' data (or RawScope) by Avantes.</p>"},{"location":"reference/avaread/reader/#avaread.reader.STRFile.dark","title":"dark","text":"<pre><code>dark\n</code></pre> <p>Return the Dark signal array (or background), constrained to the range of active pixels.</p>"},{"location":"reference/avaread/reader/#avaread.reader.STRFile.ref","title":"ref","text":"<pre><code>ref\n</code></pre> <p>Return the Reference signal array, constrained to the range of active pixels.</p>"},{"location":"reference/avaread/reader/#avaread.reader.STRFile.signal","title":"signal","text":"<pre><code>signal\n</code></pre> <p>Return the dark-corrected signal for all frames, constrained to the range of active pixels.</p>"},{"location":"reference/avaread/reader/#avaread.reader._extract_datetime","title":"_extract_datetime","text":"<pre><code>_extract_datetime(timestamp: int)\n</code></pre> <p>Extract a <code>datetime</code> object from a provided timestamp.</p> Source code in <code>src/avaread/reader.py</code> <pre><code>def _extract_datetime(timestamp: int):\n    \"\"\"Extract a `datetime` object from a provided timestamp.\"\"\"\n    year = timestamp &gt;&gt; 20\n    month = (timestamp &gt;&gt; 16) % 16\n    day = (timestamp &gt;&gt; 11) % 32\n    hour = (timestamp &gt;&gt; 6) % 32\n    minute = timestamp % 64\n    return datetime(year=year, month=month, day=day, hour=hour, minute=minute)\n</code></pre>"},{"location":"reference/avaread/reader/#avaread.reader.read_file","title":"read_file","text":"<pre><code>read_file(file_path: Path) -&gt; AVSFile | STRFile\n</code></pre> <p>Open a file saved by Avantes AvaSoft.</p> <p>Detects the file type from the file and returns a corresponding instance of <code>AVSFile</code> or <code>STRFile</code>.</p> Source code in <code>src/avaread/reader.py</code> <pre><code>def read_file(file_path: Path) -&gt; AVSFile | STRFile:\n    \"\"\"Open a file saved by Avantes AvaSoft.\n\n    Detects the file type from the file and returns a corresponding instance of [`AVSFile`][(m).AVSFile] or [`STRFile`][(m).STRFile].\n    \"\"\"\n    file_path = Path(file_path)\n    if not file_path.exists():\n        raise FileNotFoundError(f\"{file_path} does not exist\")\n    elif file_path.is_dir():\n        raise FileNotFoundError(f\"{file_path} is a directory, please provide a file path\")\n    with file_path.open(\"rb\") as fo:\n        prelude = fo.read(5)\n    file_format = prelude[:3].decode()\n    file_version = int(prelude[3:5]) / 10\n    if file_format.upper() == \"AVS\":\n        if file_version &lt; 8:\n            raise AvaReadException(f\"File version {file_version} is not supported.\")\n        return AVSFile(file_path)\n    elif file_format.upper() == \"STR\":\n        if file_version &lt; 8:\n            raise AvaReadException(f\"File version {file_version} is not supported.\")\n        return STRFile(file_path)\n    else:\n        raise AvaReadException(f\"{file_path.name} is not a valid Avantes AvaSoft 8 file.\")\n</code></pre>"}]}